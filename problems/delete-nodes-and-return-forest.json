{
    "problemName": "delete-nodes-and-return-forest",
    "language": "python3",
    "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\"\"\"\nclass Solution:\n    #def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:  \n    def delNodes(self, root, to_delete):\n            to_delete_set = set(to_delete)\n            res = []\n\n            def helper(root, parent_is_root):\n                if not root: return None\n                \n                root_deleted = root.val in to_delete_set\n                \n                # if it is root and it is not in the delete list, place it in the rest\n                if parent_is_root and not root_deleted:\n                    res.append(root)\n                    \n                root.left  = helper(root.left, root_deleted)\n                root.right = helper(root.right, root_deleted)\n                \n                return None if root_deleted else root\n            \n            helper(root, True)\n            \n            return res\n\"\"\"\n\n# the key is how to align different cases \n# if the node is not to be deleted, then, we furhter check its parent node exist or not (strategy)\n# there are two condidition during the DFS: \n# 1. this node is to be delete or not, \n#.   if to be deleted, remove it from the to_delete list/set, and further visite's parent node\n# 2. otherwise, if this node is not to be deleted, we check its parent exist or not, \n#    if its parent does not exist, it is root of a tree in the final forest\n# the DFS must the next node's parent's existing. \n\n# essentially, this question is to go throught the tree and record all to delete's node's children, \n# we care about which node does not have parents after deletion\n# the corner case is the root node, which does not have parent as the beginning. \n# we need to combine these different cases. \n\nclass Solution(object):\n    def delNodes(self, root: TreeNode, to_delete: List[int]) -> List[TreeNode]:\n        to_delete = set(to_delete) # use the same name\n        res = [] \n        # return the to delete node's children nodes if these children nodes will not to be deleted\n        # so, using dfs to search for the nodes not to bedelete and has no parents, that is why dfs need to carry \n        # the parent's node information\n        \n        def dfs(root, parent_exist):\n            if not root: return None\n            \n            if root.val in to_delete:\n                #to_delete.remove(root.val) # remove this element to reduce the delete checks\n                to_delete.discard(root.val)\n                root.left  = dfs(root.left, False)\n                root.right = dfs(root.right, False)\n                \n                return None  # this node will be deleted, so no return. \n            else:\n                if not parent_exist: # parent does not exist, so this is a new node as the root, must append to the result list\n                    res.append(root)  # if parent exist, we just need to move the childrens. \n                root.left  = dfs(root.left, True)\n                root.right = dfs(root.right, True)\n                \n                return root  # new tree, we must return back\n            \n        dfs(root, False)\n        \n        return res"
}