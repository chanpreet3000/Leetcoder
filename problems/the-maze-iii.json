{
    "problemName": "the-maze-iii",
    "language": "java",
    "code": "class Solution {\n    class Node implements Comparable<Node> {\n        public int row;\n        public int col;\n        public int count;\n        public String path;\n        \n        public Node(int row, int col, int count, String path) {\n            this.row = row;\n            this.col = col;\n            this.count = count;\n            this.path = path;\n        }\n        \n        public int compareTo(Node p) {\n            if (this.count == p.count) return this.path.compareTo(p.path);\n            return Integer.compare(this.count, p.count);\n        }\n    }\n    \n    public String findShortestWay(int[][] maze, int[] ball, int[] hole) {\n        int m = maze.length;\n        int n = maze[0].length;\n        \n        int[][] dirs = {{1, 0}, {0, -1}, {0, 1}, {-1, 0}};\n        String[] dirNames = {\"d\", \"l\", \"r\", \"u\"};\n        \n        Node[][] visited = new Node[m][n];\n        visited[ball[0]][ball[1]] = new Node(ball[0], ball[1], 0, \"\");\n        \n        PriorityQueue<Node> pq = new PriorityQueue<>();\n        pq.offer(visited[ball[0]][ball[1]]);\n        \n        while (!pq.isEmpty()) {\n            Node cur = pq.poll();\n            if (cur.compareTo(visited[cur.row][cur.col]) > 0) continue;\n            if (cur.row == hole[0] && cur.col == hole[1]) return cur.path;\n            \n            int k = 0;\n            for (int[] dir : dirs) {\n                int curDist = cur.count;\n                int x = cur.row;\n                int y = cur.col;\n                while (isValid(maze, x + dir[0], y + dir[1])) {\n                    x += dir[0];\n                    y += dir[1];\n                    curDist++;\n                    if (x == hole[0] && y == hole[1]) break;\n                }\n                Node next = new Node(x, y, curDist, cur.path + dirNames[k++]);\n                if (visited[x][y] == null || next.compareTo(visited[x][y]) < 0) {\n                    visited[x][y] = next;\n                    pq.offer(next);\n                }\n            }\n        }\n        return \"impossible\";\n    }\n    \n    private boolean isValid(int[][] maze, int r, int c) {\n        return r >= 0 && c >= 0 && r < maze.length && c < maze[0].length && maze[r][c] == 0;\n    }\n}"
}