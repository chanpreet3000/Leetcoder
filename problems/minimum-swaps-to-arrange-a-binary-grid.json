{
    "problemName": "minimum-swaps-to-arrange-a-binary-grid",
    "language": "cpp",
    "code": "class Solution {\npublic:\n    int minSwaps(vector<vector<int>>& grid){\n        int n = grid.size();\n        int ans = 0;\n        vector<int> t; // vector to keep track of trailing zeroes\n        \n        //Step 1 : Find all trailing zeroes\n        for(int i=0;i<n;i++){\n            int zero = 0;\n            for(int j=n-1;j>=0;j--){\n                if(grid[i][j]) break;\n                zero++;\n            }\n            t.push_back(zero);\n        }\n        \n        //Step 2 : Apply greedy method and solve problem row by row\n        for(int i=0;i<n;i++){\n            \n            int curr = i;\n            int req = n - 1 - i; // how many zeroes we want at this particular row \n            \n            // Step 4 : find nearest row which fullfill our zeroes requirement\n            while(curr < n and t[curr] < req) curr++;\n            \n            // Step 5 : If we are not able to find any such rows --> return -1\n            if(curr == n) return -1;\n            \n            // Step 6 : If we able to find such row then add cost to swap it\n            ans += curr - i;\n            \n            // Step 7 : move all such rows 1 step ahead which are in b/w the source row and dest row\n            while(curr > 0){\n                t[curr] = t[curr - 1];\n                curr--;\n            }\n            \n        }\n        \n        return ans;\n    }\n};"
}