{
    "problemName": "amount-of-time-for-binary-tree-to-be-infected",
    "language": "java",
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    TreeNode origin = null;\n    public int amountOfTime(TreeNode root, int start) {\n        \n        if(root == null)return 0;\n        HashMap<TreeNode,TreeNode> map=new HashMap<>();\n        Parent(root,start,map);\n        return bfs(map);\n    }\n    \n    private int bfs(HashMap<TreeNode,TreeNode> map){\n        \n        Queue<TreeNode> pq = new ArrayDeque<>();\n        pq.add(origin);\n        HashSet<TreeNode> vis = new HashSet<>();\n        int level=-1;\n        \n        while(pq.size()!=0){\n            int size = pq.size();\n            for(int i=0;i<size;i++){\n                TreeNode src = pq.poll();\n                if(vis.contains(src)==true)continue;\n                vis.add(src);\n                if(src.left!=null && !vis.contains(src.left)) pq.add(src.left);\n                if(src.right!=null && !vis.contains(src.right)) pq.add(src.right);\n                if(map.containsKey(src) && !vis.contains(map.get(src))) pq.add(map.get(src));\n            }\n            level++;\n        }\n        return level;\n    }\n    private void Parent(TreeNode root, int start, HashMap<TreeNode,TreeNode> map){\n        if(root==null) return;\n        \n        if(root.left!=null) map.put(root.left,root);\n        if(root.right!=null) map.put(root.right,root);\n        \n        if(root.val==start) origin=root;\n        \n        Parent(root.left,start,map);\n        Parent(root.right,start,map);\n    }\n}"
}