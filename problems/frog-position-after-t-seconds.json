{
    "problemName": "frog-position-after-t-seconds",
    "language": "java",
    "code": "class Solution {\n    \n    public double frogPosition(int n, int[][] edges, int t, int target) {\n        Deque<Object[]> deque = new ArrayDeque<>();\n        Map<Integer, List<Integer>> neigh = new HashMap<>();\n        Set<Integer> visited = new HashSet<>();\n        Deque<Integer> visitDeque = new ArrayDeque<>();\n        visitDeque.add(1);\n        \n        while (!visitDeque.isEmpty()) {\n            int it = visitDeque.poll();\n            visited.add(it);\n            List<Integer> list = new ArrayList<>();\n            for (int[] edge : edges) {\n                if (edge[0] == it && !visited.contains(edge[1])) {\n                    list.add(edge[1]);\n                    visitDeque.add(edge[1]);\n                } else if (edge[1] == it && !visited.contains(edge[0])) {\n                    list.add(edge[0]);\n                    visitDeque.add(edge[0]);\n                } \n            }\n            \n            neigh.put(it, list);\n        }\n        neigh.entrySet().removeIf(ent -> ent.getValue().isEmpty());\n        \n        deque.addLast(new Object[] {1, 1.0, 0});\n        \n        while (!deque.isEmpty()) {\n            Object[] e = deque.poll();\n            int currentNode = (int) e[0];\n            double currentProb = (double) e[1];\n            int currentTime = (int) e[2];\n            \n            if (currentNode == target) {\n                boolean targetIsLeaf = neigh.get(target) == null;\n                if (targetIsLeaf) {\n                    if (currentTime <= t) {\n                        return currentProb;\n                    } else {\n                        return 0;\n                    }\n                } else {\n                    if (currentTime == t) {\n                        return currentProb;\n                    } else {\n                        return 0;\n                    }\n                }\n            }\n            \n            List<Integer> curNeighs = neigh.get(currentNode);\n            if (curNeighs != null) {\n                double prob = currentProb * (1.0 / curNeighs.size());\n                for (int i = 0; i < curNeighs.size(); i++) {\n                    deque.add(new Object[] {curNeighs.get(i), prob, currentTime + 1});\n                }\n            }\n        }\n        \n        return 0;\n    }\n}"
}