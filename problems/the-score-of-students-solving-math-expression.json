{
    "problemName": "the-score-of-students-solving-math-expression",
    "language": "python3",
    "code": "class Solution:\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\n\n        # dp(i, j) return a dictionary of all possible results for the substring from s[i] to s[j]\n        @lru_cache(None)\n        def dp(i, j): \n            if i == j:\n                return {int(s[i])}\n\n            res = {}\n            # op is the index of the operator\n            for op in range(i+1, j, 2):\n                for a in dp(i, op-1):\n                    for b in dp(op+1, j):\n                        cur = a * b if s[op] == \"*\" else a + b\n                        if cur <= 1000:\n                            res[cur] = 2 # get 2 points for wrong order calculation \n\n            return res\n\n        # merge two dictionary:\n        # 1. dp stores the 2 points answer, which has right arithmetic but wrong order \n        # 2. eval(s) evalutes the correct answer, and assigns 5 points. \n        res = {**dp(0, len(s)-1), **{eval(s) : 5}}\n\n        return sum(res.get(a, 0) for a in answers) \n        \n\n# Time = O(k^3 * 1000^2)\n# Enumerating all substrings O(k^2),\n# then for each substring,\n# there are O(k) ways to break it into two parts,\n# then executing the math takes at most 1000^2.\n\n# More precisely,\n# size_a = min(1000, size(a)!)\n# size_b = min(1000, size(b)!)\n# k = 15 - size_a - size_b, where k > 0\n\n# The total complexity is the sum of\n# size_a * size_b * k\n# which is about 10 millions.\n# https://leetcode.com/problems/the-score-of-students-solving-math-expression/solutions/1486296/python-dp-solution-with-complexity-analysis/"
}