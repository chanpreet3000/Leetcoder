{
    "problemName": "all-paths-from-source-lead-to-destination",
    "language": "java",
    "code": "class Solution {\n    int destination;\n    Map<Integer, Set<Integer>> graph;\n    boolean[] seen;\n    public boolean leadsToDestination(int n, int[][] edges, int source, int destination) {\n\n        if(edges.length == 0) {\n            return source == destination;\n        }\n\n        graph = new HashMap<>();\n        \n        for(int i = 0; i < n; i++) {\n            graph.put(i, new HashSet<>());\n        }\n        \n        for(int[] edge : edges) {\n            if(!graph.get(edge[0]).contains(edge[1])) {\n                graph.get(edge[0]).add(edge[1]);\n            }   \n        }\n        \n        if(graph.get(destination).contains(destination) || graph.get(source).isEmpty()) {\n            return false;\n        }\n        \n        this.destination = destination;\n        this.seen = new boolean[n + 1];\n        \n        return dfs(source);\n    }\n\n    Map<Integer, Boolean> cache = new HashMap<>();\n                   \n    boolean dfs(int node) {\n\n        if(cache.containsKey(node)) {\n            return true;\n        }\n        \n        if(graph.get(node).contains(node) || (graph.get(node).isEmpty() && node != destination) || seen[node]) {\n            return false;\n        }  else if(graph.get(node).isEmpty() && node == destination) {\n            return true;\n        }\n\n        \n        \n        seen[node] = true;\n        \n        for(int neighbour : graph.get(node)) {\n            if(!dfs(neighbour)) {\n                return false;\n            }\n        }\n\n        // seen[node] = false;\n        \n        cache.put(node, true);\n\n        return true;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
}