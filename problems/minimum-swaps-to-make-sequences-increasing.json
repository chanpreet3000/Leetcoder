{
    "problemName": "minimum-swaps-to-make-sequences-increasing",
    "language": "cpp",
    "code": "class Solution {\npublic:\n    int minSwap(vector<int>& nums1, vector<int>& nums2) {\n        int n = nums1.size();\n        // dp[i][is_swap] records the min swap need to make [0, ..., i] increasing if we swap (or not) at i\n        vector<vector<int> > dp(n, vector<int>(2, INT_MAX));\n        \n        dp[0][0] = 0;\n        dp[0][1] = 1;\n        \n        for (int i = 1; i < n; i++) {\n            // proceed with same relative order\n            if (nums1[i] > nums1[i - 1] && nums2[i] > nums2[i - 1]) {\n                if (dp[i - 1][0] != INT_MAX) {\n                    dp[i][0] = min(dp[i][0], dp[i - 1][0]);\n                }\n                if (dp[i - 1][1] != INT_MAX) {\n                    dp[i][1] = min(dp[i][1], dp[i - 1][1] + 1);\n                }\n            }\n            // proceed with swapped order\n            if (nums1[i] > nums2[i - 1] && nums2[i] > nums1[i - 1]) {\n                if (dp[i - 1][1] != INT_MAX) {\n                    dp[i][0] = min(dp[i][0], dp[i - 1][1]);\n                }\n                if (dp[i - 1][0] != INT_MAX) {\n                    dp[i][1] = min(dp[i][1], dp[i - 1][0] + 1);\n                }\n            }\n        }\n        \n        return min(dp[n - 1][0], dp[n - 1][1]);\n    }\n};"
}