{
    "problemName": "shortest-path-in-a-hidden-grid",
    "language": "cpp",
    "code": "/**\n * // This is the GridMaster's API interface.\n * // You should not implement it, or speculate about its implementation\n * class GridMaster {\n *   public:\n *     bool canMove(char direction);\n *     void move(char direction);\n *     boolean isTarget();\n * };\n */\n\nclass Solution {\npublic:\n    vector<char> dirsc = {'U', 'L', 'D', 'R'};\n    vector<pair<int,int>> dirs = {{-1,0}, {0,-1}, {1,0}, {0,1}};\n    vector<vector<int>> grid;\n    int er = -1, ec;\n    int findShortestPath(GridMaster &master) {\n        grid.resize(1001, vector<int>(1001, INT_MAX));\n        grid[500][500] = 0;\n        dfs(500, 500, master);\n        if (er == -1) {\n            return -1;\n        }\n        queue<array<int,2>> que;\n        que.push({500,500});\n        int dis = 0;\n        while (que.size()) {\n            int qsize = que.size();\n            while (qsize--) {\n                auto now = que.front();\n                que.pop();\n                int r = now[0], c = now[1];\n                if (r == er && c == ec) {\n                    return dis;\n                }\n                for (auto &dir: dirs) {\n                    int nr = r+dir.first;\n                    int nc = c+dir.second;\n                    if (nr < 0 || nr > 1000 || nc < 0 || nc > 1000 || (grid[nr][nc] != 0 && grid[nr][nc] != 2)) {\n                        continue;\n                    }\n                    grid[nr][nc] = 1;\n                    que.push({nr,nc});\n                }\n            }\n            ++dis;\n        }\n        return -1;\n    }\n    void dfs(int r, int c, GridMaster &master) {\n        if (master.isTarget()) {\n            grid[r][c] = 2;\n            er = r, ec = c;\n        }\n        for (int i = 0; i < 4; ++i) {\n            int nr = r+dirs[i].first;\n            int nc = c+dirs[i].second;\n            if (master.canMove(dirsc[i])) {\n                if (grid[nr][nc] == INT_MAX) {\n                    grid[nr][nc] = 0;\n                    master.move(dirsc[i]);\n                    dfs(nr, nc, master);\n                    master.move(dirsc[(i+2)%4]);\n                }\n            } else {\n                grid[nr][nc] = 1;\n            }\n        }\n    }\n};"
}