{
    "problemName": "closest-leaf-in-a-binary-tree",
    "language": "java",
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int findClosestLeaf(TreeNode root, int k) {\n        Map<TreeNode, List<TreeNode>> graph = new HashMap<>();\n        dfs(graph, root, null);\n        Queue<TreeNode> queue = new LinkedList<>();\n        Set<TreeNode> seen = new HashSet<>();\n        for (TreeNode node: graph.keySet()) {\n            if (node != null && node.val == k) {\n                queue.add(node);\n                seen.add(node);\n            }\n        }\n        while (!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n            if (node != null) {\n                if (graph.get(node).size() <= 1)\n                    return node.val;\n                for (TreeNode nei: graph.get(node)) {\n                    if (!seen.contains(nei)) {\n                        seen.add(nei);\n                        queue.add(nei);\n                    }\n                }\n            }\n        }\n        throw null;\n    }\n    private void dfs(Map<TreeNode, List<TreeNode>> graph, TreeNode node, TreeNode parent) {\n        if (node != null) {\n            if (!graph.containsKey(node)) graph.put(node, new LinkedList<TreeNode>());\n            if (!graph.containsKey(parent)) graph.put(parent, new LinkedList<TreeNode>());\n            graph.get(node).add(parent);\n            graph.get(parent).add(node);\n            dfs(graph, node.left, node);\n            dfs(graph, node.right, node);\n        }\n    }\n}"
}