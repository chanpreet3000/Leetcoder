{
    "problemName": "minimum-adjacent-swaps-for-k-consecutive-ones",
    "language": "python3",
    "code": "import collections\n\nclass Solution:\n    def minMoves(self, nums: List[int], k: int) -> int:\n        if k == 1:\n            return 0\n\n        arr = []\n\n        c = 0\n        has_1 = False\n        for v in nums:\n            if v == 0:\n                c += 1\n            else:\n                if has_1:\n                    arr.append(c)\n                c = 0\n                has_1 = True\n\n        l = collections.deque(arr[:(k-1) // 2])\n        l_sum = sum(l)\n        r = collections.deque(arr[(k-1) // 2:k-1])\n        r_sum = sum(r)\n\n        l_moves = sum((i+1)*l[i] for i in range(len(l)))\n        r_moves = sum((len(r) - i)*r[i] for i in range(len(r)))\n\n        res = l_moves + r_moves\n        for v in arr[k-1:]:\n            rl = r[0]\n            new = v\n\n            l_moves = l_moves - l_sum + len(l) * rl\n            l.append(rl)\n            l_sum += rl - l.popleft()\n\n            r_moves = r_moves + r_sum - (len(r) + 1) * rl + new\n            r.append(new)\n\n            r_sum += new - r.popleft()\n            res = min(res, l_moves + r_moves)\n\n        return res\n\n"
}