{
    "problemName": "sentence-similarity-ii",
    "language": "java",
    "code": "class Solution {\n    // Solution 1: dfs\n    // [[\"manga\",\"onepiece\"],[\"platform\",\"anime\"],[\"leetcode\",\"platform\"],[\"anime\",\"manga\"]]\n    // \"manga\": \"onepiece\", \"anime\"\n    // \"onepiece\": \"manga\"\n    // \"platform\": \"anime\", \"leetcode\"\n    // \"anime\": \"platform\", \"manga\"\n    // \"leetcode\": \"platform\"\n    public boolean areSentencesSimilarTwo(String[] sentence1, String[] sentence2, List<List<String>> similarPairs) {\n        if (sentence1.length != sentence2.length) {\n            return false;\n        }\n\n        Map<String, List<String>> graph = buildGraph(similarPairs);\n        Set<String> seen = new HashSet<>();\n\n        for (int i = 0; i < sentence1.length; i++) {\n            // If sentence1[i] and sentence2[i] are the same word, cotinue;\n            if (sentence2[i].equals(sentence1[i])) {\n                continue;\n            }\n            // If hashmap does not contain either word, return false;\n            if (!graph.containsKey(sentence2[i]) || !graph.containsKey(sentence1[i])) {\n                return false;\n            }\n            // Perform DFS on the graph to check if sentence2[i] is reachable from sentence1[i].\n            seen = new HashSet<>();\n            if (!dfs(graph, sentence1[i], sentence2[i], seen)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private Map<String, List<String>> buildGraph(List<List<String>> similarPairs) {\n        Map<String, List<String>> graph = new HashMap<>();\n\n        for (List<String> pair : similarPairs) {\n            // Build an edge from pair[0] to pair[1]\n            graph.putIfAbsent(pair.get(0), new ArrayList<>());\n            graph.get(pair.get(0)).add(pair.get(1));\n            // Build an edge from pair[1] to pair[0]\n            graph.putIfAbsent(pair.get(1), new ArrayList<>());\n            graph.get(pair.get(1)).add(pair.get(0));\n        }\n\n        return graph;\n    }\n    private boolean dfs(Map<String, List<String>> graph, String word1, String word2, Set<String> seen) {\n        if (word1.equals(word2)) {\n            return true;\n        }\n\n        seen.add(word1);\n        for (String neighbor : graph.get(word1)) {   \n            if (!seen.contains(neighbor) && dfs(graph, neighbor, word2, seen)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    // TC: O(k + n * m), k = similarPairs.size(); n = sentence1.length, m = graph.size();\n    // SC: O(m)\n}"
}