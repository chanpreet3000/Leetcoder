{
    "problemName": "tree-of-coprimes",
    "language": "cpp",
    "code": "class Solution {\npublic:\n    void dfs(vector<vector<int>> &adj, vector<int> &nums, vector<int> &ans, map<int, vector<pair<int, int>>> &mp, int root, int par, int depth){\n        int _max = -1, res = -1;\n        for(auto &i : mp){\n            if(__gcd(i.first, nums[root]) == 1 && i.second.size() > 0){\n                auto b = i.second.back();\n                if(b.first > _max){\n                    _max = b.first;\n                    res = b.second;\n                }\n            }\n        }\n        ans[root] = res;\n        mp[nums[root]].push_back({depth, root});\n        for(auto i : adj[root]){\n            if(i != par){\n                dfs(adj, nums, ans, mp, i, root, depth + 1);\n            }\n        }\n        mp[nums[root]].pop_back();\n    }\n    vector<int> getCoprimes(vector<int>& nums, vector<vector<int>>& edges) {\n        int n = nums.size();\n        vector<vector<int>> adj(n);\n        for(auto i : edges){\n            adj[i[0]].push_back(i[1]);\n            adj[i[1]].push_back(i[0]);\n        }\n        vector<int> ans(n, -1);\n        map<int, vector<pair<int, int>>> mp;\n        dfs(adj, nums, ans, mp, 0, -1, 0);\n        return ans;\n    }\n};"
}