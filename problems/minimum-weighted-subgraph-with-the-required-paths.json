{
    "problemName": "minimum-weighted-subgraph-with-the-required-paths",
    "language": "python3",
    "code": "class Solution:\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\n        ## use Dijkstra to calcualte each node's distance to a certain node\n        g1, g2 = collections.defaultdict(list), collections.defaultdict(list)\n        for u, v, w in edges:\n            g1[u].append((v, w))\n            g2[v].append((u, w))\n            \n        def dijkstra(graph, start):\n            dist = {}\n            q = [(0, start)]\n            while q:\n                cost, node = heapq.heappop(q)\n                if node not in dist:\n                    dist[node] = cost\n                    for child, w in graph[node]:\n                        if child not in dist:\n                            heapq.heappush(q, (cost + w, child))\n                            \n            return [dist.get(node, float('inf')) for node in range(n)]\n        \n        arr1 = dijkstra(g1, src1)\n        arr2 = dijkstra(g1, src2)\n        arr3 = dijkstra(g2, dest)\n        res = float('inf')\n        for node in range(n):\n            res = min(res, arr1[node]+arr2[node]+arr3[node])\n           \n        if res == float('inf'):\n            return -1\n        return res\n        \n        \n                        \n        "
}