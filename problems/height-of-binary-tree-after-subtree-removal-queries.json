{
    "problemName": "height-of-binary-tree-after-subtree-removal-queries",
    "language": "java",
    "code": "class Solution {\n    int leftMax;\n    int rightMax;\n    \n    public int[] treeQueries(TreeNode root, int[] queries) {\n        leftMax = 0;\n        rightMax = 0;\n        \n        int[] allL = new int[100001];\n        int[] res = new int[queries.length];\n\n        dfsLeft(root, 0, allL);\n        dfsRight(root, 0, allL);\n        \n        for(int i = 0; i < queries.length; i++){\n            res[i] = allL[queries[i]];\n        }\n        return res;\n    }\n    \n    public void dfsLeft(TreeNode root, int level, int[] allL){\n        if(root == null) return;\n        allL[root.val] = leftMax;\n        leftMax = Math.max(leftMax, level);\n        dfsLeft(root.left, level + 1, allL);\n        dfsLeft(root.right, level + 1, allL);\n    }\n    \n     public void dfsRight(TreeNode root, int level, int[] allL){\n        if(root == null) return;\n        allL[root.val] = Math.max(rightMax, allL[root.val]);\n        rightMax = Math.max(rightMax, level);\n        dfsRight(root.right, level + 1, allL);\n        dfsRight(root.left, level + 1, allL);\n    }\n}\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */"
}