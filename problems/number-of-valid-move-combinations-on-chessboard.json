{
    "problemName": "number-of-valid-move-combinations-on-chessboard",
    "language": "python3",
    "code": "class Solution:\n    def __init__(self) -> None:\n        rook_dirs = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n        bish_dirs = [(1, 1), (1, -1), (-1, 1), (-1, -1)]\n        self.dirs = {\"rook\": rook_dirs, \"bishop\": bish_dirs, \"queen\": rook_dirs + bish_dirs}\n        \n        # Generate 2D arrays as boards for each piece (4 max)\n        self.boards = [[[0] * 8 for _ in range(8)] for _ in range(4)]\n\n    def countCombinations(self, pieces: List[str], positions: List[List[int]], piece_id: int = 0) -> int:\n        if piece_id >= len(pieces):\n            return 1\n\n        start_x, start_y, res = positions[piece_id][0] - 1, positions[piece_id][1] - 1, 0\n        piece_name = pieces[piece_id]\n\n        for dx, dy in self.dirs[piece_name]:\n            blocked = False\n            step = 1 if res == 0 else 2  # First move count is \"stay at start point\"\n\n            while not blocked:\n                nx = start_x + (step - 1) * dx\n                ny = start_y + (step - 1) * dy\n\n                # Check bounds of move is within board\n                if min(nx, ny) < 0 or max(nx, ny) > 7:\n                    break\n\n                can_stop = True\n\n                for pp in range(piece_id):\n                    # Can stop if no other pieces stopped at that position and\n                    # other pieces already went through that position\n                    can_stop &= self.boards[pp][nx][ny] >= 0 and self.boards[pp][nx][ny] < step\n\n                    # A position is blocked if it is:\n                    # a final one for another piece with smaller/same number of steps to get there, or\n                    # a transitional position for another piece with the same number of steps to get there.\n                    blocked |= (self.boards[pp][nx][ny] < 0 and -self.boards[pp][nx][ny] <= step) or (\n                        self.boards[pp][nx][ny] == step\n                    )\n\n                if can_stop:\n                    # Mark with negative steps as this piece currently occupies it.\n                    self.boards[piece_id][nx][ny] = -step\n                    res += self.countCombinations(pieces, positions, piece_id + 1)\n\n                self.boards[piece_id][nx][ny] = step  # Unmark current cell as occupied\n\n                step += 1\n\n            # Clear board for this piece\n            self.boards[piece_id] = [[0] * 8 for _ in range(8)]\n\n        return res"
}