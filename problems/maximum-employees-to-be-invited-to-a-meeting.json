{
    "problemName": "maximum-employees-to-be-invited-to-a-meeting",
    "language": "cpp",
    "code": "class Solution {\npublic:\n\n    unordered_map<int, vector<int>> graph;\n    vector<int> in_degrees;\n    vector<int> longest_chain;\n\n    static bool cmpDescend(int lhs, int rhs) {\n        return lhs > rhs;\n    }\n\n    int dfs(int x, vector<bool>& visited, int length, vector<int>& max_chains, vector<int>& favorite, vector<int>& close_loops) {\n        visited[x] = 1;\n        int nxt = favorite[x];\n        if (visited[nxt]) {\n            int ret = length + 1;\n            if (length + 1 == 2) {\n                sort(max_chains.begin(), max_chains.end(), cmpDescend);\n                int close_loop_length = length + 1 + max_chains[0] + max_chains[1];\n                ret = max(ret, close_loop_length);\n                close_loops.push_back(close_loop_length);\n            }\n            return ret;\n        }\n        max_chains.push_back(longest_chain[nxt]);\n        return dfs(nxt, visited, length + 1, max_chains, favorite, close_loops);\n    }\n\n    int maximumInvitations(vector<int>& favorite) {\n        int n = favorite.size();\n        in_degrees.resize(n, 0);\n        longest_chain.resize(n, 0);\n        for (int i = 0; i < n; ++i) {\n            int x = i;\n            int y = favorite[i];\n            graph[x].push_back(y);\n            in_degrees[y] += 1;\n        }\n        queue<int> que;\n        for (int i = 0; i < n; ++i) {\n            if (in_degrees[i] == 0) {\n                que.push(i);\n            }\n        }\n        while (!que.empty()) {\n            int x = que.front();\n            que.pop();\n            int nxt = favorite[x];\n            longest_chain[nxt] = max(longest_chain[nxt], longest_chain[x] + 1);\n            in_degrees[nxt] -= 1;\n            if (in_degrees[nxt] == 0) {\n                que.push(nxt);\n            }\n        }\n        vector<bool> visited(n, 0);\n        int ans = 0;\n        vector<int> close_loops;\n        for (int i = 0; i < n; ++i) {\n            if (in_degrees[i] != 0) {\n                if (!visited[i]) {\n                    vector<int> max_chains = {longest_chain[i]};\n                    ans = max(ans, dfs(i, visited, 0, max_chains, favorite, close_loops));\n                }\n            }\n        }\n        int sum = 0;\n        for (const auto& val : close_loops) {\n            sum += val;\n        }\n        ans = max(ans, sum);\n        return ans;\n    }\n};"
}