{
    "problemName": "split-array-with-equal-sum",
    "language": "python3",
    "code": "#class Solution:\n#    def splitArray(self, nums: List[int]) -> bool:\n        \n        \n#Let A be the array. As in most problems involving querying the sum of contiguous elements of an array, let P[x] = sum(A[:x]) be the prefix sums of A, which can be found in linear time.\n\n#Then the sums in question are P[i] = P[j] - P[i+1] = P[k] - P[j+1] = P[-1] - P[k+1]. For every j < k, P[i] = P[-1] - P[k+1] is a necessary requirement to choose i, so let's iterate over those indices first. This gives us the advantage that since we are iterating over a sorted list of candidate indices i, we can break when i >= j.\n\n\"\"\"\nclass Solution:\n    def splitArray(self, nums):\n            n = len(nums)\n            s = [0] * (n + 1)\n            for i in range(n): s[i + 1] = s[i] + nums[i]\n            def check(l, r):\n                return set(s[m] - s[l] for m in range(l + 1, r + 1) if s[m] - s[l] == s[r + 1] - s[m + 1])\n            return any(check(0, j - 1) & check(j + 1, n - 1) for j in range(n))\n\"\"\"\n\n# O(N^2): prefix sum + set operation\n# partition the array into four parts\n# 1. parition two parts first, with pivot 2 (j) first, get two partitions:  (0, j - 1),  (j + 1, n - 1)\n# 2. for the above two part, further partion one into two repsctively, use set to buffer all the partition sum, \n# 3. if the two sections intersections, there is solutions. \n# 4. not include i, j, k indexed element,  so, j at least from 3, and at most end with n - 3\n\nfrom itertools import accumulate\n\nclass Solution:\n    def splitArray(self, nums: List[int]) -> bool:\n        n = len(nums)\n        if n < 4: # to make there is not empty partition first\n            return False\n            \n        prefix_sum = [0] + list(accumulate(nums))  # why we need padding? at index i,  the prefix_sum[i]  does not include nums[i]\n        s = prefix_sum  # for prefix sum, should be careful to see if the prefix sum include the current element or not. \n            \n        def check(l, r): # include l and r in nums[],  m is the partition point here. \n            return set(s[m] - s[l] for m in range(l + 1, r) if s[m] - s[l] == s[r + 1] - s[m + 1]) # partition sum set with all equal partions\n        \n        return any(check(0, mid - 1) & check(mid + 1, n - 1) for mid in range(3, n - 3)) # partition it into two with index j,   # set operation of the sums, "
}