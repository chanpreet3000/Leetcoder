{
    "problemName": "nested-list-weight-sum-ii",
    "language": "python3",
    "code": "# \"\"\"\n# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n#class NestedInteger:\n#    def __init__(self, value=None):\n#        \"\"\"\n#        If value is not specified, initializes an empty list.\n#        Otherwise initializes a single integer equal to value.\n#        \"\"\"\n#\n#    def isInteger(self):\n#        \"\"\"\n#        @return True if this NestedInteger holds a single integer, rather than a nested list.\n#        :rtype bool\n#        \"\"\"\n#\n#    def add(self, elem):\n#        \"\"\"\n#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\n#        :rtype void\n#        \"\"\"\n#\n#    def setInteger(self, value):\n#        \"\"\"\n#        Set this NestedInteger to hold a single integer equal to value.\n#        :rtype void\n#        \"\"\"\n#\n#    def getInteger(self):\n#        \"\"\"\n#        @return the single integer that this NestedInteger holds, if it holds a single integer\n#        Return None if this NestedInteger holds a nested list\n#        :rtype int\n#        \"\"\"\n#\n#    def getList(self):\n#        \"\"\"\n#        @return the nested list that this NestedInteger holds, if it holds a nested list\n#        Return None if this NestedInteger holds a single integer\n#        :rtype List[NestedInteger]\n#        \"\"\"\n\nclass Solution:\n    def depthSumInverse(self, nestedList: List[NestedInteger]) -> int:\n        sol = []\n        def dfs(curr, depth):\n            if depth > len(sol):\n                sol.append(0)\n            \n            if curr.getInteger():\n                sol[depth-1] += curr.getInteger()\n                return\n            for i in curr.getList():\n                dfs(i, depth +1)\n                \n        for i in nestedList:\n            dfs(i, 1)\n            \n        max_depth = len(sol)\n        for i in range(max_depth):\n            sol[i] = (max_depth -i)*sol[i]\n        \n        return sum(sol)\n                \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        "
}