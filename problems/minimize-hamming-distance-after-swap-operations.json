{
    "problemName": "minimize-hamming-distance-after-swap-operations",
    "language": "cpp",
    "code": "class Solution {\r\npublic:\r\n    vector<int> parent, sz;\r\n    int find_set(int x){\r\n        if(parent[x] == x) return x;\r\n        return parent[x] = find_set(parent[x]);\r\n    }\r\n\r\n    void make_union(int x, int y){\r\n        int a = find_set(x);\r\n        int b = find_set(y);\r\n        if(a != b){\r\n            if(sz[a] < sz[b]) swap(a, b);\r\n            parent[b] = a;\r\n            sz[a] += sz[b];\r\n        }\r\n    }\r\n\r\n    int minimumHammingDistance(vector<int>& source, vector<int>& target, vector<vector<int>>& swaps) {\r\n        int n = source.size();\r\n        parent.resize(n);\r\n        sz.resize(n);\r\n        for(int i = 0; i<n; i++){\r\n            parent[i] = i;\r\n            sz[i] = 1;\r\n        }\r\n\r\n        for(int i = 0; i<swaps.size(); i++){\r\n            int x = swaps[i][0];\r\n            int y = swaps[i][1];\r\n            make_union(x, y);\r\n        }\r\n\r\n        unordered_map<int, unordered_map<int, int>> mp;\r\n        for(int i = 0; i<n; i++){\r\n            int x = find_set(i);\r\n            int val = source[i];\r\n            mp[x][val]++;\r\n        }\r\n\r\n        int hamming_distance = 0;\r\n        for(int i = 0; i<n; i++){\r\n            int x = find_set(i);\r\n            int val = target[i];\r\n            if(mp[x].find(val) == mp[x].end()) hamming_distance++;\r\n            else{\r\n                if(mp[x][val] > 0) mp[x][val]--;\r\n                else{\r\n                  hamming_distance++;\r\n                }\r\n            }\r\n        }\r\n        // for(auto it : mp){\r\n        //     auto x = it.second;\r\n        //     for(auto y : x){\r\n        //       hamming_distance += (abs(y.second));\r\n        //     }\r\n        // }\r\n        return hamming_distance;\r\n    }\r\n};"
}