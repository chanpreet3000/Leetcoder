{
    "problemName": "pyramid-transition-matrix",
    "language": "cpp",
    "code": "class Solution {\npublic:\n    unordered_map<string, vector<char>> allowedMap;\n    unordered_set<string> visited;\n    \n    bool pyramidTransition(string bottom, vector<string>& allowed) {\n        int bottomLength = bottom.size();\n        for (auto& str : allowed) {\n            string cur = str.substr(0, 2);\n            if (!allowedMap.count(cur)) allowedMap[cur];\n            allowedMap[cur].push_back(str[2]);\n        }\n        return dfs(bottom, string());\n    }\n    \n    bool dfs(string& base,  string top) {\n        if (base.size() == 1) return true;\n        if (top.size() < base.size() - 1) {\n            string cur = base.substr(top.size(), 2);\n            for (char& ch : allowedMap[cur]) {\n                if(dfs(base, top + ch)) return true;\n            }\n        }\n        else if (top.size() == base.size() - 1 && !visited.count(top)) {\n            visited.insert(top);\n            return dfs(top, string());\n        }\n        return false;\n    }\n    \n    unordered_map<string, vector<char>> m;\n    bool dfs1(string &bottom, string top) {\n        if (top.size() == bottom.size() - 1)\n            return top.empty() ? true : dfs(top, string());\n        for (auto ch : m[bottom.substr(top.size(), 2)])\n            if (dfs(bottom, top + ch))\n                return true;\n        return false;\n    }\n    bool pyramidTransition1(string bottom, vector<string>& allowed) {\n        for (auto &s : allowed)\n            m[s.substr(0, 2)].push_back(s[2]);\n        return dfs(bottom, string());\n    }\n};"
}