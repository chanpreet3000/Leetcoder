{
    "problemName": "people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list",
    "language": "cpp",
    "code": "class Solution {\npublic:\n    vector<int> peopleIndexes(vector<vector<string>>& favoriteCompanies) {\n        \n        \n        //idea here, convert each company to an index/id; what I was thinking; key is to store a list of hash sets for each person, key is for each guy's favoirte company indices, we see if any of the unordered_sets contains all of the values; however this still requires making up to 500 iterations all othe r100 persons, not ideal, plus we there are 100 people resulting in aroudn 5,000,000 operations, which is not ideal\n        \n        //what I was thinking, maybe store each guy's favorite companies in a bit string; that way we would still check every other guy's bit string for each person's favorite, but we just need to do an or and see if it changes the other guy's data to know if there are any differences\n        \n        //however based on hint it seems like they're ok with naive solutionk, of simply storin ghash sets for each person\n        \n        //was also thinking of other ideas, like sorting the list of company indices and using a trie, but it doesn't work since we're looking for subsets, and it could be possible a superset has some other indices; like we could have 0,2 in one list, and 0,1,2 in another list, in this case trie wouldn't work\n        \n        unordered_map<string, int> companyToIndex;\n        int currentIndex = 1;\n        vector<unordered_set<int>> uniqueCompanyFavoriteLists;\n        for (auto &companyList: favoriteCompanies) {\n            unordered_set<int> currentUniqueIndices;\n            for (auto &company: companyList) {\n                int companyIndex;\n                if (!companyToIndex.count(company)) {\n                    companyToIndex[company] = currentIndex;\n                    companyIndex = currentIndex;\n                    currentIndex++;\n                } else {\n                    companyIndex = companyToIndex[company];\n                }\n                currentUniqueIndices.insert(companyIndex);\n            }\n            uniqueCompanyFavoriteLists.push_back(currentUniqueIndices);\n        }\n        vector<int> uniqueIndices;\n        for (int i=0; i<uniqueCompanyFavoriteLists.size(); i++) {\n            bool supersetFound = false;\n            for (int j=0; j<uniqueCompanyFavoriteLists.size(); j++) {\n                if (i!=j) {\n                    bool fullContainment = true;\n                    for (auto &companyIndex: uniqueCompanyFavoriteLists[i]) {\n                        if (!uniqueCompanyFavoriteLists[j].count(companyIndex)) {\n                            fullContainment = false;\n                            break;\n                        } \n                    }\n                    \n                    if (fullContainment == true) {\n                        supersetFound = true;\n                    }\n                    \n                    if (supersetFound) {\n                        break;\n                            \n                    }\n                }\n            }\n            if (!supersetFound) {\n                uniqueIndices.push_back(i);\n            }\n        }\n        return uniqueIndices;\n    }\n};"
}