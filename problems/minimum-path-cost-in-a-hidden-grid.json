{
    "problemName": "minimum-path-cost-in-a-hidden-grid",
    "language": "cpp",
    "code": "/**\n * // This is the GridMaster's API interface.\n * // You should not implement it, or speculate about its implementation\n * class GridMaster {\n *   public:\n *     bool canMove(char direction);\n *     int move(char direction);\n *     boolean isTarget();\n * };\n */\nusing AI3 = array<int, 3>;\nclass Solution {\n    int grid[201][201];\n    int seen[201][201];\n    int seen2[201][201];\n    int DIRS[4][2] = {{0,1}, {0,-1},{1,0},{-1,0}};\n    string mvs = \"RLDU\";\npublic:\n    int findShortestPath(GridMaster &master) {\n        \n        seen[100][100] = 1;\n        dfs(master, 100, 100);\n        \n        return dijkstra(100, 100);\n    }\n    \n    int dijkstra(int i, int j) {\n        \n        priority_queue<AI3, vector<AI3>, greater<AI3>> q;\n        q.push({0, i, j});\n        seen2[i][j] = 1;\n        \n        while (!q.empty()) {\n            auto [c, x, y] = q.top();\n            q.pop();\n            \n            \n            for (int k = 0; k < 4; k++) {\n                int nX = x + DIRS[k][0];\n                int nY = y + DIRS[k][1];\n                \n                if (nX < 0 || nX > 200 ||\n                    nY < 0 || nY > 200 ||\n                    grid[nX][nY] == 0 ||\n                    seen2[nX][nY]) continue;\n                \n                seen2[nX][nY] = 1;\n                if (grid[nX][nY] < 0) {\n                    return c - grid[nX][nY];\n                }\n                q.push({c + grid[nX][nY], nX, nY});\n            }\n        }\n        return -1;\n    }\n    \n    void dfs(GridMaster &master, int i, int j) {\n    \n        \n        if (master.isTarget()) {\n            grid[i][j] *= -1;\n        }\n        \n        for (int k = 0; k < 4; k++) {\n            int x = i + DIRS[k][0], y = j + DIRS[k][1];\n            if (x < 0 || x > 200 || y < 0 || y > 200 ||\n                seen[x][y] || !master.canMove(mvs[k]))\n                continue;\n            \n            seen[x][y] = 1;\n            grid[x][y] = master.move(mvs[k]);\n            dfs(master, x, y);\n            \n            int kk = 4;\n            if (k == 0) kk = 1;\n            else if (k == 1) kk = 0;\n            else if (k == 2) kk = 3;\n            else kk = 2;\n            master.move(mvs[kk]);\n        }\n    }\n};"
}