{
    "problemName": "longest-substring-with-at-most-k-distinct-characters",
    "language": "python3",
    "code": "#class Solution:\n#    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -> int:\n \n\"\"\"\n    The general idea is to iterate over string s.\n    Always put the character c and its location i in the dictionary d.\n    1) If the sliding window contains less than or equal to k distinct characters, simply record the return value, and move on.\n    2) Otherwise, we need to remove a character from the sliding window.\n       Here's how to find the character to be removed:\n       Because the values in d represents the rightmost location of each character in the sliding window, in order to find the longest substring T, we need to  locate the smallest location, and remove it from the dictionary, and then record the return value.\n\"\"\"\n\n# Use dictionary d to keep track of (character, location) pair,\n# where location is the rightmost location that the character appears at\n# essentially, it is a kind of sliding window.\n\n#\"\"\"\nclass Solution(object):\n    def lengthOfLongestSubstringKDistinct(self, s, k):\n        d = {} # the dicitonary keep the right most index of that charater\n        left, ret = 0, 0\n        \n        # left and right maintained the window\n        for right, c in enumerate(s):\n            d[c] = right  # update it the right most index,  do not need the historgram as counter. [we do not care about the existing ones, so over write it]\n            while len(d) > k: # if we want to change the ditionary key range, we must change the charater with left \n                left = min(d.values()) # must remove the left element's right most index, otherwise the size of dicitonary still > k\n                d.pop(s[left])\n                left += 1 # remember to move the left index\n            ret = max(right - left + 1, ret)\n            \n        return ret\n#\"\"\"\n    \n\"\"\"\n# get some error\nclass Solution(object):\n    def lengthOfLongestSubstringKDistinct(self, s, k):\n        d = {} # the dicitonary keep the right most index of that charater\n        left, ret = 0, 0\n        left_idx = deque() \n        \n        for right, c in enumerate(s):\n            d[c] = right  # update it the right most index,  do not need the historgram as counter. \n            left_idx.append(right)\n            while len(d) > k:\n                #left = min(d.values()) # must remove the left element's right most index, otherwise the size of dicitonary still > k\n                left = left_idx.popleft()\n                del d[s[left]]\n                if left_idx: \n                    left += 1\n                #left = left_Idx \n            ret = max(right - left + 1, ret)\n            \n        return ret\n\"\"\""
}