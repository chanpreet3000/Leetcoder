{
    "problemName": "design-most-recently-used-queue",
    "language": "java",
    "code": "class MRUQueue {\n    class Node {\n        int val;\n        Node next;\n        Node prev;\n        \n        public Node(int v) {\n            val = v;\n        }\n    }\n    \n    private static int step = 50; // alternatively it could be Math.sqrt(n)\n    Node[] skipNodes;\n    Node head;\n    int MRUQueueLength;\n    \n    public MRUQueue(int n) {\n        MRUQueueLength = n;\n        int m = n / step;\n        skipNodes = new Node[m];\n        head = new Node(0);\n        Node cur = head;\n        int idx = 0;\n        int j = 1;\n        for (int i = n; i > 0; i--, j++) {\n            Node next = new Node(i);\n            cur.next = next;\n            next.prev = cur;\n            if (j == step) {\n                skipNodes[idx++] = next;\n                j = 0;\n            }\n            cur = next;\n        }\n    }\n    \n    public int fetch(int k) {\n        int index = 0;\n        int nodeIndex = MRUQueueLength - k + 1; // our list has reverse order\n        Node cur = head;\n        while(nodeIndex >= step) {\n            nodeIndex -= step;\n            cur = skipNodes[index];\n            skipNodes[index] = skipNodes[index].prev;\n            index++;\n        }\n        \n        while(nodeIndex > 0) {\n            cur = cur.next;\n            nodeIndex--;\n        }\n        \n        // delete cur from Linked List\n        if (cur.next != null) cur.next.prev = cur.prev;\n        cur.prev.next = cur.next;\n\t\t// insert cur after the head\n        cur.next = head.next;\n        if (head.next != null) head.next.prev = cur;\n        cur.prev = head;\n        head.next = cur;\n        \n        return cur.val;\n    }\n}"
}