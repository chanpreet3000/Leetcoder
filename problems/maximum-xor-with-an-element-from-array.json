{
    "problemName": "maximum-xor-with-an-element-from-array",
    "language": "cpp",
    "code": "class Solution {\n    public:\n    struct Trie {\n        Trie* next[2];\n        Trie () {next[0] = nullptr; next[1] = nullptr;};\n    };\n    Trie* buildTree(vector<int>& nums) {\n        Trie* root = new Trie(), *curr;\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            int num = nums[i];\n            curr = root;\n            for (int j = 31; j >= 0; j--) {\n                int index = ((num >> j) & 1);\n                if (curr->next[index] == nullptr)\n                    curr->next[index] = new Trie();\n                curr = curr->next[index];\n            }\n        }\n        return root;\n    }\n    \n    int dfs(Trie* root, int x, int limit, int value, int height) {\n        if (value > limit) return -1;\n        \n        if (height == -1) return x^value;\n        \n        int bit_x = (x >> height) & 1;\n        \n        if (root->next[1-bit_x] != nullptr) {\n            int v = dfs(root->next[1-bit_x], x, limit, (value | ((1-bit_x) << height)), height-1);\n            if (v >= 0) return v;\n        }\n        if (root->next[bit_x] != nullptr) {\n            int v = dfs(root->next[bit_x], x, limit, (value | (bit_x << height)), height-1);\n            if (v >= 0) return v;\n        }\n        \n        return -1;\n    }\n    \n    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<int> ans;\n        Trie* root = buildTree(nums);\n        \n        for (const vector<int>& query : queries) {            \n            int tmp = dfs(root, query[0], query[1], 0, 31);\n            ans.push_back(tmp);\n        }\n        \n        return ans;\n    }\n};"
}