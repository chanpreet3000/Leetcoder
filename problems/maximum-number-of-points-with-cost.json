{
    "problemName": "maximum-number-of-points-with-cost",
    "language": "java",
    "code": "/*\ncurr[j] stores values when we pick points[i][j] of that row\nwe assume thats the maximum value when we pick that element\nwe maintain left right to store whats the maximum coming from previous rows to maintain current maximum\n\n*/\n\nclass Solution {\n    public long maxPoints(int[][] points) {\n        \n        int rows = points.length;\n        int cols = points[0].length;\n        \n        long[] prev = new long[cols];\n        \n        for (int i = 0; i < cols; i++) {\n            prev[i] = points[0][i];\n        }\n        \n        for (int i = 1; i < rows; i++) {\n            long[] left = new long[cols];\n            long[] right = new long[cols];\n            long curr[] = new long[cols];\n            \n            left[0] = prev[0];\n            right[cols - 1] = prev[cols - 1];\n            \n            for (int j = 1; j < cols; j++) {\n                left[j] = Math.max(left[j-1] - 1, prev[j]);\n            }\n            \n            for (int j = cols - 2; j >= 0; j--) {\n                right[j] = Math.max(right[j+1] - 1, prev[j]);\n            }\n            \n            for (int j = 0; j < cols; j++) {\n                curr[j] = points[i][j] + Math.max(left[j], right[j]);\n            }\n            \n            prev = curr;\n        }\n        \n        long maxPoints = 0;\n        for (int j = 0; j < cols; j++) {\n            maxPoints = Math.max(maxPoints, prev[j]);\n        }\n        return maxPoints;\n    }\n\n}"
}