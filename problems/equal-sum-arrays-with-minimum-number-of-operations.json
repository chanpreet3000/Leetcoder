{
    "problemName": "equal-sum-arrays-with-minimum-number-of-operations",
    "language": "cpp",
    "code": "class Solution {\npublic:\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\n\t    // not possible to equalize under following conditions\n        if(6 * nums1.size() < 1 * nums2.size() || 6 * nums2.size() < 1 * nums1.size())\n            return -1;\n        int diff = 0, op = 0, j = 5;\n        vector<int>arr(6);\n        diff = accumulate(begin(nums1), end(nums1), 0) - accumulate(begin(nums2), end(nums2), 0);\n        // if diff is positive, switch array bcoz numbers from first array will be used for subtracting and vice-versa\n        if(diff > 0) swap(nums1, nums2);\n        // arr stores frequency of numbers(1-5) that can be subtracted from diff to make it 0\n        for(int &num : nums1) arr[6 - num]++;  \n        for(int &num : nums2) arr[num - 1]++;        \n        diff = abs(diff);\n        \n        while(diff > 0){\n            if(arr[j]){\n                op += min(arr[j], (int)ceil(1.0 * diff / j));\n                diff -= arr[j] * j;\n                if(diff <= 0)return op;                \n            }\n\t\t\tj--;\n\t\t}\n        return op;\n    }\n\n};"
}