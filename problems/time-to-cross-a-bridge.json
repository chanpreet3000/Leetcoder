{
    "problemName": "time-to-cross-a-bridge",
    "language": "csharp",
    "code": "using System.Diagnostics;\n\n\tpublic class Solution\n\t{\n\t\t[Conditional(\"DEBUG\")]\n\t\tvoid debugMessage(string message)\n\t\t{\n\t\t\t//Console.WriteLine(message);\n\t\t}\n\n\t\tclass Worker\n\t\t{\n\t\t\tpublic int ID { get; }\n\t\t\tpublic int RightToLeftTime { get; }\n\t\t\tpublic int LeftToRightTime { get; }\n\n\t\t\tpublic int TotalMoveTime { get; }\n\n\t\t\tpublic int PickUpBox { get; }\n\t\t\tpublic int PutDownABox { get; }\n\n\t\t\tpublic int CurrentBoxTime = 0;\n\n\t\t\tpublic Worker(int id, int leftToRightTime, int pickUp, int rightToLeftTime, int putDown)\n\t\t\t{\n\t\t\t\tthis.ID = id;\n\n\t\t\t\tthis.LeftToRightTime = leftToRightTime;\n\t\t\t\tthis.RightToLeftTime = rightToLeftTime;\n\t\t\t\tthis.TotalMoveTime = LeftToRightTime + RightToLeftTime;\n\n\t\t\t\tthis.PickUpBox = pickUp;\n\t\t\t\tthis.PutDownABox = putDown;\n\t\t\t}\n\n\t\t\tpublic void WorkOnTask(int time)\n\t\t\t{\n\t\t\t\tCurrentBoxTime -= time;\n\t\t\t}\n\t\t}\n\n\t\tclass WaitForBridgeComparer : IComparer<Worker>\n\t\t{\n\t\t\tpublic int Compare(Worker x, Worker y)\n\t\t\t{\n\t\t\t\tif (x.TotalMoveTime > y.TotalMoveTime)\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\telse if (x.TotalMoveTime < y.TotalMoveTime)\n\t\t\t\t{\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn y.ID - x.ID;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic int FindCrossingTime(int numBoxes, int numWorkers, int[][] time)\n\t\t{\n\t\t\t//https://leetcode.com/problems/time-to-cross-a-bridge/\n\n\t\t\tWaitForBridgeComparer comparer = new WaitForBridgeComparer();\n\t\t\tvar waitingToGoRight = new SortedSet<Worker>(comparer);\n\t\t\tvar waitingToGoLeft = new SortedSet<Worker>(comparer);\n\t\t\tint timeTaken = 0;\n\n\t\t\t// TODO: Could cache this, so we don't have to search for the lowest current task remaining time\n\t\t\tvar pickingUpFromRight = new HashSet<Worker>();\n\t\t\tvar puttingDownOnLeft = new HashSet<Worker>();\n\n\t\t\tList<Worker> workers = new List<Worker>();\n\n\t\t\tfor (int workerIndex = 0; workerIndex < numWorkers; workerIndex++)\n\t\t\t{\n\t\t\t\tint[] workerTimes = time[workerIndex];\n\t\t\t\tWorker worker = new Worker(workerIndex, workerTimes[0], workerTimes[1], workerTimes[2], workerTimes[3]);\n\t\t\t\tworkers.Add(worker);\n\t\t\t\twaitingToGoRight.Add(worker);\n\t\t\t}\n\n\t\t\tvoid doBoxWork(int time)\n\t\t\t{\n\t\t\t\t// Decrement picker ups\n\t\t\t\tList<Worker> toRemove = new List<Worker>();\n\t\t\t\tforeach (Worker worker in pickingUpFromRight)\n\t\t\t\t{\n\t\t\t\t\tworker.WorkOnTask(time);\n\t\t\t\t\tif (worker.CurrentBoxTime <= 0)\n\t\t\t\t\t\ttoRemove.Add(worker);\n\t\t\t\t}\n\t\t\t\tforeach (Worker worker in toRemove)\n\t\t\t\t{\n\t\t\t\t\tdebugMessage($\"Worker {worker.ID} has finished picking up\");\n\t\t\t\t\tpickingUpFromRight.Remove(worker);\n\t\t\t\t\twaitingToGoLeft.Add(worker);\n\t\t\t\t}\n\t\t\t\ttoRemove.Clear();\n\n\t\t\t\t// Decrement dropper offers\n\t\t\t\tforeach (Worker worker in puttingDownOnLeft)\n\t\t\t\t{\n\t\t\t\t\tworker.WorkOnTask(time);\n\t\t\t\t\tif (worker.CurrentBoxTime <= 0)\n\t\t\t\t\t\ttoRemove.Add(worker);\n\t\t\t\t}\n\t\t\t\tforeach (Worker worker in toRemove)\n\t\t\t\t{\n\t\t\t\t\tdebugMessage($\"Worker {worker.ID} has finished putting down\");\n\t\t\t\t\tputtingDownOnLeft.Remove(worker);\n\t\t\t\t\twaitingToGoRight.Add(worker);\n\t\t\t\t}\n\n\t\t\t\ttimeTaken += time;\n\t\t\t}\n\n\t\t\t// Check if anyone is waiting to go across bridge, if so, cross bridge, increment eveyrones task count by bridge cross time\n\t\t\t// If no one is waiting on bridge, increment all times by lowest remainging task time\n\t\t\t// Repeat\n\n\t\t\twhile (numBoxes > 0 || waitingToGoLeft.Count > 0 || pickingUpFromRight.Count > 0)\n\t\t\t{\n\n\t\t\t\t// Check if anyone is waiting to go across bridge, if so, cross bridge, increment eveyrones task count by bridge cross time\n\n\t\t\t\t//            If a worker x reaches the bridge while another worker y is crossing the bridge, x waits at their side of the bridge.\n\t\t\t\t//If the bridge is free, the worker waiting on the right side of the bridge gets to cross the bridge.If more than one worker is waiting on the right side, the one with the lowest efficiency crosses first.\n\t\t\t\t//If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge.If more than one worker is waiting on the left side, the one with the lowest efficiency crosses first.\n\n\t\t\t\tif (waitingToGoLeft.Count > 0)\n\t\t\t\t{\n\t\t\t\t\tWorker walker = waitingToGoLeft.First();\n\t\t\t\t\twaitingToGoLeft.Remove(walker);\n\n\t\t\t\t\tdebugMessage($\"Working {walker.ID} has gone to drop off\");\n\n\t\t\t\t\t// Decrement task time by walk time\n\t\t\t\t\tdoBoxWork(walker.RightToLeftTime);\n\n\t\t\t\t\t// Putting it down\n\t\t\t\t\twalker.CurrentBoxTime = walker.PutDownABox;\n\t\t\t\t\tputtingDownOnLeft.Add(walker);\n\t\t\t\t}\n\t\t\t\telse if (waitingToGoRight.Count > 0 && numBoxes > 0)\n\t\t\t\t{\n\t\t\t\t\tWorker walker = waitingToGoRight.First();\n\t\t\t\t\twaitingToGoRight.Remove(walker);\n\n\t\t\t\t\tdebugMessage($\"Working {walker.ID} has gone to pickup\");\n\n\t\t\t\t\t// Decrement task time by walk time\n\t\t\t\t\tdoBoxWork(walker.LeftToRightTime);\n\t\t\t\t\tnumBoxes--;\n\n\t\t\t\t\t// Start picking up box\n\t\t\t\t\twalker.CurrentBoxTime = walker.PickUpBox;\n\t\t\t\t\tpickingUpFromRight.Add(walker);\n\t\t\t\t}\n\t\t\t\telse if (pickingUpFromRight.Count > 0 || puttingDownOnLeft.Count > 0)\n\t\t\t\t{\n\t\t\t\t\t// Find the lowest remaining task time\n\t\t\t\t\tint taskTime = pickingUpFromRight.Concat(puttingDownOnLeft).Min(w => w.CurrentBoxTime);\n\n\n\t\t\t\t\t// Do the work\n\t\t\t\t\tdoBoxWork(taskTime);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn timeTaken;\n\t\t}\n\n\t}\n"
}