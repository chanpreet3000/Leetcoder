{
    "problemName": "count-the-number-of-ideal-arrays",
    "language": "golang",
    "code": "func modInverse(b int64, m int64) *big.Int {\n\tbBig := big.NewInt(b)\n\tmBig := big.NewInt(m)\n\treturn bBig.Exp(bBig, big.NewInt(m-2), mBig)\n}\n// func computeFactoriaMod(mod int64, modInverses [10005]int64) ([10030]int64, [10030]int64) {\n//     var i int64 = 1\n//     var j int64 = 1\n//     dp1 := [10030]int64{}\n//     dp2 := [10030]int64{}\n//     for i <= 10030 {\n        \n//     }\n// }\nfunc cnk(n int64, k int64, m int64, modInverses [10005]int64) int64 {\n\tvar rs int64 = 1\n\tvar i int64 = 1\n\tfor {\n\t\tif i > k {\n\t\t\tbreak\n\t\t}\n\t\tx := (rs % m * (i + n - k) % m) % m\n\t\trs = (x % m * modInverses[i] % m) % m\n\t\ti++\n\t}\n\treturn rs\n}\nfunc idealArrays(n int, maxValue int) int {\n\tvar mod int64 = 1e9 + 7\n\tvar rs int64 = 0\n\tmodInverses := [10005]int64{}\n\tfor i := int64(1); i <= int64(n); i++ {\n\t\tmodInverses[i] = modInverse(i, mod).Int64()\n\t}\n\t// fmt.Println(\"HEHEH\")\n\tndist := 15\n\t// dp := make([][]int64, 16)\n\tdp := [16][10005]int64{}\n\tm := [10005][]int{}\n\tk := n-1\n\tcombi := cnk(int64(1+k-1), int64(k), mod, modInverses)\n\tfor j := 1; j <= maxValue; j++ {\n\t\tdp[0][j] = 1\n\t\tif k >= 0 {\n\t\t\tt := ((combi % mod) * (dp[0][j] % mod)) % mod\n\t\t\trs = (rs%mod + t%mod) % mod\n\t\t}\n\t\tx := j + j\n\t\tfor {\n\t\t\tif x > maxValue {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tm[x] = append(m[x], j)\n\t\t\tx = x + j\n\t\t}\n\t}\n\n\tfor i := 1; i < ndist; i++ {\n\t\tk = n - (i + 1)\n\t\tcombi = cnk(int64(i+1+k-1), int64(k), mod, modInverses)\n\t\tfor j := 1; j <= maxValue; j++ {\n\t\t\tdp[i][j] = 0\n\t\t\tfor _, k := range m[j] {\n\t\t\t\tif j%k == 0 {\n\t\t\t\t\tdp[i][j] = (dp[i][j]%mod + dp[i-1][k]%mod) % mod\n\t\t\t\t}\n\t\t\t}\n\t\t\tif k >= 0 {\n\t\t\t\tt := ((combi % mod) * (dp[i][j] % mod)) % mod\n\t\t\t\trs = (rs%mod + t%mod) % mod\n\t\t\t}\n\t\t}\n\t\t// fmt.Println(dp[i])\n\t}\n\treturn int(rs)\n}"
}