{
    "problemName": "number-of-restricted-paths-from-first-to-last-node",
    "language": "python3",
    "code": "class Solution:\n    def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:\n        if n == 1: return 0\n        graph = defaultdict(list)\n        for u, v, w in edges:\n            graph[u].append((w, v))\n            graph[v].append((w, u))\n\n        def dijkstra():  # Dijkstra to find shortest distance of paths from node `n` to any other nodes\n            minHeap = [(0, n)]  # dist, node\n            dist = [float('inf')] * (n + 1)\n            dist[n] = 0\n            while minHeap:\n                d, u = heappop(minHeap)\n                if d != dist[u]: continue\n                for w, v in graph[u]:\n                    if dist[v] > dist[u] + w:\n                        dist[v] = dist[u] + w\n                        heappush(minHeap, (dist[v], v))\n            return dist\n\n        @lru_cache(None)\n        def dfs(src):\n            if src == n: return 1  # Found a path to reach to destination\n            ans = 0\n            for _, nei in graph[src]:\n                if dist[src] > dist[nei]:\n                    ans = (ans + dfs(nei)) % 1000000007\n            return ans\n        \n        dist = dijkstra()\n        return dfs(1)\n# from copy import copy\n\n# class Solution:\n#     def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:\n#         # n: node수, 1~n까지 node label\n#         # edges: from, to, weight\n#         # dinstanceToLastNode(x): n부터 arbitrary node x 까지의 shortest distance\n#         # dinstanceToLastNode(z_i) > distanceToLastNode(z_{i+1}) 인 경우 restricted path\n#         # 1에서 n까지 가는데 restricted path 수\n#         # cost는 n에서 시작, path는 1에서 n까지 가는 길\n#         # dijkstra로 cost를 만든 다음 현재 node의 cost보다 작거나같은거만 선택하면됨\n\n#         # O(E)\n#         cost_map: Dict[int, Tuple[int]] = defaultdict(list)\n#         for from_node, to_node, weight in edges:\n#             cost_map[from_node].append((to_node, weight))\n#             cost_map[to_node].append((from_node, weight))\n\n#         weights: List[int] = [float('inf')] * (n + 1) # 0번 index는 사용안함\n#         weights[n] = 0\n#         heap: List[Tuple[int]] = [(0, n)]\n#         node: int\n#         weight: int\n#         # E * VlogV\n#         while len(heap) > 0:\n#             weight, node = heappop(heap)\n#             if weights[node] is not None and weights[node] < weight:\n#                 continue # weight 이 더 크면 더이상 진행을 안하게됨\n\n#             # E per V\n#             for to_node, edge_weight in cost_map[node]:\n#                 if weights[to_node] > weights[node] + edge_weight:\n#                     weights[to_node] = weights[node] + edge_weight\n#                     heappush(heap, (weights[to_node], to_node))\n\n#         def dfs(node: int) -> int:\n#             if node == n:\n#                 return 1\n#             res: int = 0\n\n#             for next_node, _ in cost_map[node]:\n#                 if weights[node] > weights[next_node]:\n#                     res = (res + dfs(next_node)) % 1000000007\n#             return res\n        \n#         return dfs(1)\n"
}