{
    "problemName": "linked-list-in-binary-tree",
    "language": "ruby",
    "code": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {ListNode} head\n# @param {TreeNode} root\n# @return {Boolean}\ndef is_sub_path(head, root)\n    queue = [root]\n    until queue.empty?\n        current = queue.shift\n        return true if dfs(head, current)\n        queue << current.left if current.left\n        queue << current.right if current.right\n    end\n    return false\nend\n\n\n\ndef dfs(head, root)\n    return true if !head\n    return false if !root\n    return false if root.val != head.val\n    return dfs(head.next, root.left) || dfs(head.next, root.right)\nend\n\n# BFS the tree. for each node, run a DFS check if it's the head of the linked list\n# DFS: base case is to return true if we've reached the end of the linked list and the pointer to the node in the linked list is null\n# return false if we have more linked list nodes to check but the subtree is out of nodes\n# return false if the current linked list node's value differs from the current tree node's."
}