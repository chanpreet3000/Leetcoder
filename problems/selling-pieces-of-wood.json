{
    "problemName": "selling-pieces-of-wood",
    "language": "cpp",
    "code": "class Solution {\npublic:\n    \n    // Ref: https://leetcode.com/problems/selling-pieces-of-wood/discuss/2170082/Partition-DP-Recursion-greaterMemoization-greaterTabulation-greaterSpace-Optimization\n\tlong long sellingWood(int m, int n, vector<vector<int>>& prices) {     \n\t\t//Base case is tackled in this declaration as we initialized the dp array with 0.\n\t\tvector<vector<long long>> dp(m+1,vector<long long>(n+1,0)); \n\n\t\t//Storing Prices in dp array itself\n\t\tfor(int i = 0;i < prices.size();i++)\n\t\t\tdp[prices[i][0]][prices[i][1]] = prices[i][2];\n\n\t\tfor(int row = 1;row <= m;row++){ //loop reversed\n\t\t\tfor(int col = 1;col <= n;col++){ //loop reversed\n\n\t\t\t\t//Base Case is tackled under this\n\t\t\t\tlong long ans = dp[row][col]; \n\n\t\t\t\tfor(int i = 1;i <= row/2;i++)  //Partitions Row-wise\n\t\t\t\t\tans = max(ans,dp[i][col] + dp[row-i][col]);\n\n\t\t\t\tfor(int j = 1;j <= col/2;j++) //Partitions Column-wise\n\t\t\t\t\tans = max(ans,dp[row][j] + dp[row][col-j]);\n\n\t\t\t\t//store ans in dp array before returning so that we can use it again.\n\t\t\t\tdp[row][col] = ans;\n\t\t\t}\n\t\t}\n\n\t\treturn dp[m][n];\n\t}\n};"
}