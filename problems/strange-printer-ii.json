{
    "problemName": "strange-printer-ii",
    "language": "java",
    "code": "class Solution {\n    public boolean isPrintable(int[][] targetGrid) {\n        int LEFT = 0, RIGHT = 1, TOP = 2, BOTTOM = 3;\n        Map<Integer, int[]> coordinates = new HashMap<>();  // {left, right, top, bottom}\n        Map<Integer, Set<Integer>> adj = new HashMap<>();   // adjacency list for colors\n        Map<Integer, Integer> indegree = new HashMap<>();\n        Queue<Integer> q = new LinkedList<>();\n        \n        int m = targetGrid.length, n = targetGrid[0].length;\n        \n        // Finding the stretch of each color\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                int color = targetGrid[i][j];\n                if (coordinates.containsKey(color)) {\n                    int[] coordinate = coordinates.get(color);\n                    coordinate[LEFT] = Math.min(coordinate[LEFT], j);\n                    coordinate[RIGHT] = Math.max(coordinate[RIGHT], j);\n                    coordinate[TOP] = Math.min(coordinate[TOP], i);\n                    coordinate[BOTTOM] = Math.max(coordinate[BOTTOM], i);\n                } else {\n                    coordinates.put(color, new int[]{j, j, i, i});\n                    adj.put(color, new HashSet<>());\n                }\n            }\n        }\n        \n        // Building an adjacency list\n        for (Map.Entry<Integer, int[]> entry : coordinates.entrySet()) {\n            Integer currentColor = entry.getKey();\n            int[] coordinate = entry.getValue();\n            for (int i = coordinate[TOP]; i <= coordinate[BOTTOM]; ++i) {\n                for (int j = coordinate[LEFT]; j <= coordinate[RIGHT]; ++j) {\n                    int color = targetGrid[i][j];\n                    if (currentColor != color) {\n                        adj.get(currentColor).add(color);\n                    }\n                }\n            }\n            indegree.put(currentColor, 0);\n        }\n        \n        // Update indegrees of each color\n        for (Set<Integer> entry : adj.values()) {\n            for (int color : entry) {\n                indegree.put(color, indegree.get(color) + 1);\n            }\n        }\n        \n        // Add nodes with zero indegree to the queue\n        for (Map.Entry<Integer, Integer> entry : indegree.entrySet()) {\n            if (entry.getValue() == 0)\n                q.add(entry.getKey());\n        }\n        \n\t\t// Kahn's algorithm in action\n        int size = 0;\n        while (!q.isEmpty()) {\n            int currentColor = q.remove();\n            size++;\n            for (int color : adj.get(currentColor)) {\n                indegree.put(color, indegree.get(color) - 1);\n                if (indegree.get(color) == 0)\n                    q.add(color);\n            }\n        }\n        \n\t\t// If there was a cycle, all the nodes wouldn't have been processed, \n\t\t// since there is no valid topological order.\n        return size == adj.size();\n    }\n}"
}