{
    "problemName": "find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree",
    "language": "javascript",
    "code": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {number[][]}\n */\nvar findCriticalAndPseudoCriticalEdges = function(n, edges) {\n  function MST() {\n    let dsu = new DSU(n);\n    let ans = 0;\n      \n    const arr = edges.slice().sort((a,b) => a[2] - b[2]);   \n    for (let [u,v,w] of arr) {\n      if (dsu.union(u,v)) ans += w; \n    }  \n    \n    return ans;  \n  }\n \n    for (let i=0;i<edges.length;i++) {\n        edges[i][2] *= 2;\n    }\n    \n  let M = MST();\n  let crit = [], pseu = [];\n    \n  for (let i=0;i<edges.length;i++) {\n    edges[i][2] += 1;  \n      \n    if (MST() > M) {\n      crit.push(i);   edges[i][2] -= 1;  \n    } else {\n        edges[i][2] -= 2;\n        if (MST() < M)  pseu.push(i);\n       edges[i][2] += 1; \n    }\n  }  \n    \n    \n  return [crit, pseu];  \n};\n\n\n\n\n\n \n  class DSU {\n    constructor(N) {\n      this.par = [...Array(N)].map((_,idx) => idx);\n      this.rank = Array(N).fill(0);\n    }   \n      \n    find(x) {\n      if (this.par[x] != x) {\n        this.par[x] = this.find(this.par[x]);  \n      }  \n        \n      return this.par[x];  \n    }  \n      \n    union(x, y) {\n      let xr = this.find(x), yr = this.find(y);\n        \n      if (xr == yr) return false;\n      if (this.rank[xr] < this.rank[yr]) [xr,yr] = [yr,xr];\n      if (this.rank[xr] == this.rank[yr]) this.rank[xr]++;\n        \n      this.par[yr] = xr; \n       \n      return true;  \n    }  \n  }  \n"
}