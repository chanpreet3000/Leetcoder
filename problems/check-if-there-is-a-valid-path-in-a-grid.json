{
    "problemName": "check-if-there-is-a-valid-path-in-a-grid",
    "language": "java",
    "code": "class Solution {\n    int[][][] dirs = {\n                {{0, -1}, {0, 1}},\n                {{-1, 0}, {1, 0}},\n                {{0, -1}, {1, 0}},\n                {{0, 1}, {1, 0}},\n                {{0, -1}, {-1, 0}},\n                {{0, 1}, {-1, 0}}\n    };\n    //the idea is you need to check port direction match, you can go to next cell and check whether you can come back.\n    public boolean hasValidPath(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        boolean[][] visited = new boolean[m][n];\n        Queue<int[]> q = new LinkedList<>();\n        q.add(new int[]{0, 0});\n        visited[0][0] = true;\n        while (!q.isEmpty()) {\n            int[] cur = q.poll();\n            int x = cur[0], y = cur[1];\n            int num = grid[x][y] - 1;\n            for (int[] dir : dirs[num]) {\n                int nx = x + dir[0], ny = y + dir[1];\n                if (nx < 0 || nx >= m || ny < 0 || ny >= n || visited[nx][ny]) continue;\n                //go to the next cell and come back to orign to see if port directions are same\n                for (int[] backDir : dirs[grid[nx][ny] - 1])\n                    if (nx + backDir[0] == x && ny + backDir[1] == y) {\n                        visited[nx][ny] = true;\n                        q.add(new int[]{nx, ny});\n                    }\n            }\n        }\n        return visited[m - 1][n - 1];\n    }\n}"
}