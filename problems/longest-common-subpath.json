{
    "problemName": "longest-common-subpath",
    "language": "java",
    "code": "class Solution {\n    \n    //Rolling hash technique from Rabin-Karp algorithm\n    //https://leetcode.com/problems/longest-common-subpath/discuss/1319639/C%2B%2B-Easy-Solution-using-Rolling-Hash-with-Explanation\n    //e.g. hash function result of AAB for base 10, modulo 10 -> ((A-A)^10*10 + (A-A)^10 + (B-A)^1) % 10 = 1\n    \n    long base = 100001, mod = 66718903;\n\n    public int longestCommonSubpath(int n, int[][] paths) {\n        int minPathLengthIndex = 0;\n        for(int i = 0; i < paths.length; i++) {\n            if(paths[i].length < paths[minPathLengthIndex].length) {\n                minPathLengthIndex = i;\n            }\n        }\n        int left = 0;\n        int right = paths[minPathLengthIndex].length;\n        while(left < right) {\n            int mid = (left + right + 1) / 2;\n            Map<Long, List<Integer>> hashOccurenceMap = null;\n            for(int i = 0; i < paths.length && (i == 0 || !hashOccurenceMap.isEmpty()); ++i) {\n                long hash = 0, d = 1;\n                Map<Long, List<Integer>> currHashOccurenceMap = new HashMap<>();\n                for(int j = 0; j < paths[i].length; ++j) {\n                    hash = (hash * base + paths[i][j]) % mod;\n                    if(j >= mid) {\n                        hash = (mod + hash - d * paths[i][j - mid] % mod) % mod;\n                    }\n                    else {\n                        d = d * base % mod;    \n                    }\n                    if(j >= mid - 1) {\n                        if(i == 0) {\n                            List<Integer> list = currHashOccurenceMap.getOrDefault(hash, new ArrayList<Integer>());\n                            list.add(j + 1 - mid);\n                            currHashOccurenceMap.put(hash, list);\n                        }\n                        else {\n                            if(hashOccurenceMap.containsKey(hash)) {\n                                for(Integer pos : hashOccurenceMap.get(hash)) {\n                                    boolean match = true;\n                                    int index2 = j + 1 - mid;\n                                    for(int index1 = pos; index1 < pos + mid; index1++) {\n                                        if(paths[0][index1] != paths[i][index2]) {\n                                            match = false;\n                                            break;\n                                        }\n                                        index2++;\n                                    }\n                                    if(match) {\n                                        List<Integer> list = currHashOccurenceMap.getOrDefault(hash, new ArrayList<Integer>());\n                                        list.add(pos);\n                                        currHashOccurenceMap.put(hash, list);\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                hashOccurenceMap = currHashOccurenceMap;\n            }\n            if(hashOccurenceMap.isEmpty()) {\n                right = mid - 1;\n            }\n            else {\n                left = mid;   \n            }\n        }\n        return left;\n    }\n\n    \n}"
}