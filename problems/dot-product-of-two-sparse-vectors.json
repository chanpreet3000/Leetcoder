{
    "problemName": "dot-product-of-two-sparse-vectors",
    "language": "python",
    "code": "class SparseVector:\n    def __init__(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        \"\"\"\n        \n        self.index = []\n        \n        # two pointer solution\n        \n        for i, n in enumerate(nums):\n            if n != 0:\n                self.index.append((i, n))\n        \n        # Hashmap Solution \n        \n#         self.lut = {}\n        \n#         for i, n in enumerate(nums):\n#             if n != 0:\n#                 self.lut[i] = n\n\n    # Return the dotProduct of two sparse vectors\n    def dotProduct(self, vec):\n        \"\"\"\n        :type vec: 'SparseVector'\n        :rtype: int\n        \"\"\"\n        \n        left = 0\n        right = 0\n        out = 0\n        \n        # note: the hashmap solution is bad for very large vectors\n        # as there may be hash collisions as we hit the memory limit.\n        # the two pointer solution helps this, and they allow sequential\n        # access which is faster than random access (like haspmap)\n        # can do even better using *BINARY SEARCH*?\n        \n        # two pointer solution\n        \n        while left < len(self.index) and right < len(vec.index):\n            if self.index[left][0] == vec.index[right][0]:\n                out += self.index[left][1] * vec.index[right][1]\n                left += 1\n                right += 1\n            elif self.index[left][0] < vec.index[right][0]:\n                left += 1\n            else:\n                right += 1\n                    \n        return out\n        \n        \n        # Hashmap solution\n        \n#         def mydot(a, b):\n#             out = 0\n#             for idx in a:\n#                 if idx in b:\n#                     out += a[idx] * b[idx]\n#             return out\n        \n#         if len(self.lut) < len(vec.lut):\n#             return mydot(self.lut, vec.lut)\n#         else:\n#             return mydot(vec.lut, self.lut)\n\n\n        \n\n# Your SparseVector object will be instantiated and called as such:\n# v1 = SparseVector(nums1)\n# v2 = SparseVector(nums2)\n# ans = v1.dotProduct(v2)"
}